<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Physician Bio PDF Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --page-width: 816px;
      --page-height: 1056px;
      --margin: 48px;
      --label-color: #000;
      --body-color: #000;
      --muted-color: #333;
      --accent-color: #0b5d9d;
    }

    /* ===== Base layout & typography ===== */

    html,
    body {
      margin: 0;
      padding: 0;
      font-family: "Calibri", "Trebuchet MS", Arial, sans-serif;
      background: #f7f7f7;
      color: var(--body-color);
    }

    .app {
      max-width: 1024px;
      margin: 24px auto;
      padding: 20px 18px 24px;
      background: #fff;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
    }

    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.4rem;
      gap: 12px;
    }

    .app h1 {
      font-size: 22px;
      margin: 0;
      color: var(--accent-color);
    }

    .sub {
      color: var(--muted-color);
      margin: 4px 0 18px;
      font-size: 14px;
      line-height: 1.4;
    }

    /* Search Doctors link – styled as a subtle secondary button */
    .search-link {
      font-size: 0.9rem;
      text-decoration: none;
      color: #0b4d92;
      border: 1px solid #0b4d92;
      padding: 4px 10px;
      border-radius: 16px;
      white-space: nowrap;
      background: #f5f9ff;
    }

    .search-link:hover {
      background: #0b4d92;
      color: #ffffff;
    }

    /* ===== Input area (above preview) ===== */

    .input-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
      margin-bottom: 18px;
    }

    @media (min-width: 900px) {
      .input-grid {
        grid-template-columns: 1.25fr 0.85fr;
      }
    }

    .input-panel,
    .photo-upload {
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      background: #fafafa;
      padding: 14px 14px 12px;
    }

    .input-panel {
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.03);
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 6px;
      font-size: 13px;
      color: #222;
      letter-spacing: 0.02em;
    }

    textarea {
      width: 100%;
      min-height: 220px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      line-height: 1.5;
      border: 1px solid #d3d3d3;
      border-radius: 6px;
      padding: 8px 9px;
      resize: vertical;
      background: #ffffff;
      box-sizing: border-box;
      transition: border-color 0.15s ease, box-shadow 0.15s ease,
        background-color 0.15s ease;
    }

    textarea:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 2px rgba(11, 93, 157, 0.16);
      background-color: #fbfdff;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .hint {
      font-size: 12px;
      color: #555;
      margin-top: 8px;
      line-height: 1.4;
    }

    .photo-upload {
      background: #fbfbfb;
      border-style: dashed;
      border-color: #c4c4c4;
    }

    .photo-upload label {
      margin-bottom: 4px;
    }

    .photo-upload input[type="file"] {
      display: block;
      margin: 2px 0 8px;
      font-size: 12px;
    }

    .photo-preview {
      width: 100%;
      aspect-ratio: 3 / 4;
      background: #f0f0f0;
      border-radius: 6px;
      overflow: hidden;
      display: grid;
      place-items: center;
      color: #777;
      margin-top: 4px;
      cursor: paste;
      border: 2px dashed #bbb;
      font-size: 12px;
      text-align: center;
      padding: 4px;
    }

    .photo-preview:focus {
      border-color: #0b5d9d;
      outline: none;
    }

    .photo-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
    }

    /* ===== Buttons & controls ===== */

    button {
      background: var(--accent-color);
      color: #fff;
      border: none;
      padding: 9px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      transition: background 0.15s ease, box-shadow 0.15s ease,
        transform 0.05s ease;
    }

    button:hover {
      background: #084778;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.18);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    button.secondary {
      background: #444;
    }

    button.secondary:hover {
      background: #222;
    }

    button.ghost {
      background: #efefef;
      color: #333;
    }

    button.ghost:hover {
      background: #e3e3e3;
    }

    .preview-wrap {
      margin-top: 18px;
    }

    .preview-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      font-size: 13px;
    }

    .preview-controls label {
      font-weight: 500;
      margin: 0;
    }

    .font-size-control {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      border-radius: 20px;
      background: #f4f4f4;
    }

    .font-size-control input[type="range"] {
      width: 130px;
    }

    .font-size-control span {
      font-size: 12px;
      color: #666;
      min-width: 36px;
      text-align: right;
    }

    .editable-hint {
      font-size: 11px;
      color: #666;
      margin-left: auto;
    }

    /* ===== PDF page & content ===== */

    .page {
      width: var(--page-width);
      min-height: var(--page-height);
      margin: 0 auto;
      background: #fff;
      border: 1px solid #e5e5e5;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
      position: relative;
      overflow: visible;
    }

    .page-inner {
      padding: var(--margin);
      padding-top: 24px;
      padding-bottom: calc(var(--margin) - 8px);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Hide guides and border when capturing for PDF/Print */
    .page.printing {
      border: none;
      box-shadow: none;
    }

    .page.printing .page-guide {
      display: none !important;
    }

    /* Page guide for multi-page indicator */
    .page-guide {
      position: absolute;
      left: 0;
      right: 0;
      border-top: 1px dashed rgba(200, 0, 0, 0.7);
      pointer-events: none;
    }

    .page-guide span {
      position: absolute;
      right: 8px;
      top: -10px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 0 4px;
      color: #c00;
    }

    /* Logo */
    .logo-container {
      display: flex;
      justify-content: center;
      margin-bottom: 16px;
    }

    .logo-container img {
      height: 100px;
      width: auto;
      margin-bottom: 20px;
    }

    /* Header / name block */
    .bio-header h2 {
      margin: 0 0 4px 0;
      font-size: 20px;
      font-weight: 700;
      line-height: 1.2;
      color: #000;
    }

    .bio-header .credentials {
      font-size: 20px;
      color: var(--body-color);
      font-weight: 400;
    }

    .bio-header .specialty {
      margin-top: 2px;
      font-style: italic;
      font-size: 20px;
      color: #000;
      font-weight: 400;
    }

    .divider {
      border-top: 1px solid #000;
      margin: 8px 0 8px;
    }

    /* Content with photo float */
    .content-wrapper {
      display: block;
      flex: 1;
      min-height: 0;
    }

    .photo-box {
      float: left;
      width: 180px;
      height: 240px;
      margin-right: 20px;
      margin-bottom: 12px;
      border: 1px solid #ddd;
      background: #f5f5f5;
      display: grid;
      place-items: center;
      overflow: hidden;
    }

    .photo-box img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .photo-placeholder {
      color: #666;
      font-size: 11px;
      padding: 8px;
      text-align: center;
    }

    /* Fields */
    .fields {
      display: block;
    }

    .field {
      margin-bottom: 8px;
      display: block;
      overflow: hidden;
    }

    .field.hidden {
      display: none;
    }

    .field.clear-float {
      clear: left;
    }

    .field-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 2px;
    }

    .section-toggle {
      cursor: pointer;
      width: 14px;
      height: 14px;
      margin: 0;
      display: none;
    }

    .editable .section-toggle {
      display: inline-block;
    }

    .label {
      font-weight: 700;
      color: var(--label-color);
      font-size: 12px;
      margin: 0;
      letter-spacing: 0.2px;
    }

    .value {
      font-size: 11px;
      line-height: 1.5;
      color: var(--body-color);
      letter-spacing: 0.1px;
    }

    .value.muted {
      color: var(--muted-color);
    }

    /* Lists */
    .list {
      margin: 0 0 0 16px;
      padding: 0;
      font-size: 11px;
      line-height: 1.5;
    }

    .list li {
      margin: 2px 0;
    }

    /* Editable hint & outline */
    .editable .value,
    .editable .list {
      outline: 1px dashed rgba(11, 93, 157, 0.35);
      outline-offset: 2px;
      cursor: text;
    }

    /* Location block tweaks */
    #locationsField strong {
      display: block;
      margin-top: 0.35em;
    }
    #locationsField strong:first-child {
      margin-top: 0;
    }

    .page .value,
    .page .field ul li {
      line-height: 1.62; /* improved readability */
    }

    /* ===== Print styles ===== */

    @media print {
      body {
        margin: 0;
        padding: 0;
        background: #ffffff;
      }

      /* Hide UI chrome when printing */
      .input-grid,
      .preview-controls,
      .sub,
      h1 {
        display: none !important;
      }

      .app {
        box-shadow: none;
        border-radius: 0;
        margin: 0;
        padding: 0;
      }

      .page {
        border: none;
        box-shadow: none;
        margin: 0 auto;
      }

      .page .page-guide {
        display: none !important;
      }

      .search-link {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="header-row">
      <h1>Physician Bio Generator</h1>
      <a
        href="https://www.hopkinsmedicine.org/profiles"
        target="_blank"
        rel="noopener"
        class="search-link"
      >
        Search Doctors
      </a>
    </div>

    <div class="sub">
      Paste the text from the physician's Johns Hopkins page, upload a photo, and generate a printable PDF
      (supports multiple pages; guides show where pages break).
    </div>

    <!-- ===== Input area (text + photo) ===== -->
    <div class="input-grid">
      <div class="input-panel">
        <label for="rawInput">Pasted page text</label>
        <textarea
          id="rawInput"
          placeholder="Paste the physician's page text here..."
        ></textarea>
        <div class="actions">
          <button id="parseBtn">Parse and preview</button>
          <button id="clearBtn" class="ghost">Clear</button>
        </div>
        <div class="hint">
          Tip: Select all (CTRL+A) text on the physician bio page and copy (CTRL+C) it.
          Paste (CTRL+V) it into the above input box. Then Right-click &gt; Copy the physician photo,
          left-click on the gray box to the right and paste (CTRL+V) the image.
        </div>
      </div>

      <div class="photo-upload">
        <label for="photoFile">Upload physician photograph</label>
        <input type="file" id="photoFile" accept="image/*" />
        <div class="photo-preview" id="photoPreview" tabindex="0">
          <span id="photoPreviewText">Paste or upload a photo</span>
          <img id="photoPreviewImg" alt="Physician Photo Preview" />
        </div>
        <div class="hint">
          Recommended aspect ratio is 3:4; the image will be cropped to fit.
          You can also paste an image directly into the gray box.
        </div>
      </div>
    </div>

    <!-- ===== Preview controls & page ===== -->
    <div class="preview-wrap">
      <div class="preview-controls">
        <label>
          <input type="checkbox" id="editToggle" />
          Enable inline editing
        </label>

        <div class="font-size-control">
          <label for="fontSizeSlider">Font size:</label>
          <input
            type="range"
            id="fontSizeSlider"
            min="8"
            max="22"
            value="14"
            step="0.5"
          />
          <span id="fontSizeValue">14px</span>
        </div>

        <span class="editable-hint">
          Click any text in the preview to adjust before exporting.
        </span>

        <button id="printBtn" class="secondary" title="Print this page">
          Print
        </button>

        <button id="downloadBtn" class="secondary" title="Download as PDF">
          Download PDF
        </button>
      </div>

      <!-- PDF Content -->
      <div class="page" id="pdfPage">
        <div class="page-inner" id="pageInner">
          <div class="logo-container">
            <img src="jhm.png" alt="Johns Hopkins Medicine Logo" />
          </div>

          <div class="bio-header">
            <h2 id="nameField">Physician Name</h2>
            <div class="credentials" id="credentialsField">Credentials</div>
            <div class="specialty" id="specialtyField">Specialty</div>
          </div>

          <div class="divider"></div>

          <div class="content-wrapper">
            <div class="photo-box">
              <img id="photoImg" alt="Physician Photo" />
              <div class="photo-placeholder" id="photoPlaceholder"></div>
            </div>

            <div class="fields" id="fieldsColumn">
              <div class="field" data-field="affiliations">
                <div class="field-header">
                  <input type="checkbox" class="section-toggle" checked />
                  <div class="label">Johns Hopkins Affiliations:</div>
                </div>
                <div class="value" id="affiliationsField">—</div>
              </div>

              <div class="field" data-field="languages">
                <div class="field-header">
                  <input type="checkbox" class="section-toggle" checked />
                  <div class="label">Languages:</div>
                </div>
                <div class="value" id="languagesField">—</div>
              </div>

              <div class="field" data-field="gender">
                <div class="field-header">
                  <input type="checkbox" class="section-toggle" checked />
                  <div class="label">Gender:</div>
                </div>
                <div class="value" id="genderField">—</div>
              </div>

              <div class="field" data-field="titles">
                <div class="field-header">
                  <input type="checkbox" class="section-toggle" checked />
                  <div class="label">Professional Titles:</div>
                </div>
                <ul class="list value" id="titlesList"></ul>
              </div>

              <div class="field" data-field="academic">
                <div class="field-header">
                  <input type="checkbox" class="section-toggle" checked />
                  <div class="label">Primary Academic Title:</div>
                </div>
                <div class="value" id="academicTitleField">—</div>
              </div>

              <div class="field" data-field="background">
                <div class="field-header">
                  <input type="checkbox" class="section-toggle" checked />
                  <div class="label">Background:</div>
                </div>
                <div class="value" id="backgroundField">—</div>
              </div>

              <div class="field" data-field="education">
                <div class="field-header">
                  <input type="checkbox" class="section-toggle" checked />
                  <div class="label">Education:</div>
                </div>
                <ul class="list value" id="educationList"></ul>
              </div>

              <div class="field" data-field="certifications">
                <div class="field-header">
                  <input type="checkbox" class="section-toggle" checked />
                  <div class="label">Board Certifications:</div>
                </div>
                <ul class="list value" id="certificationsList"></ul>
              </div>

              <div class="field" data-field="memberships">
                <div class="field-header">
                  <input type="checkbox" class="section-toggle" checked />
                  <div class="label">Memberships:</div>
                </div>
                <ul class="list value" id="membershipsList"></ul>
              </div>

              <div class="field" data-field="locations">
                <div class="field-header">
                  <input type="checkbox" class="section-toggle" checked />
                  <div class="label">Locations:</div>
                </div>
                <div class="value" id="locationsField">—</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ===== Libraries from cdnjs ===== -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/3.0.3/jspdf.umd.min.js"
    integrity="sha512-+EeCylkt9WHJk5tGJxYdecHOcXFRME7qnbsfeMsdQL6NUPYm2+uGFmyleEqsmVoap/f3dN/sc3BX9t9kHXkHHg=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"
    integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
    /* ============================================================
       Basic text utilities
       ============================================================ */

    // Normalize raw text (strip \r, tabs, trim)
    function clean(text) {
      return (text || "").replace(/\r/g, "").replace(/\t/g, " ").trim();
    }

    // Split pasted content into usable lines, with some heuristics
    function lines(text) {
      // Normalize weird linebreaks
      let t = clean(text).replace(/\u2028|\u2029/g, "\n"); // rare line-separator chars

      // If there are no newlines at all, heuristically inject some
      if (!t.includes("\n")) {
        t = t.replace(
          /(Johns Hopkins Medicine|Back to search|Share:|Print|Locations|Languages|Gender|Education|Background|Board Certifications?|Memberships?|Professional Titles?|Primary Academic Title)/g,
          "\n$1"
        );
      }

      // Split + basic filtering (no truncation)
      return t
        .split("\n")
        .map((s) => s.trim())
        .filter(
          (s) =>
            s &&
            !/^show more$/i.test(s) &&
            !/^show less$/i.test(s)
        );
    }

    // Simple debounce helper for layout recalculations
    function debounce(fn, delay) {
      let timeoutId;
      return function (...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    function normalizeSpaces(s) {
      return s.replace(/\s+/g, " ").trim();
    }

    function titleCase(s) {
      return s.replace(/\w\S*/g, (t) => t.charAt(0).toUpperCase() + t.slice(1));
    }

    function escapeHtml(s) {
      return s
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    // Insert bullets into specialties where formatting was stripped
    function fixSpecialtyFormatting(s) {
      if (!s) return "";
      let out = s.trim();

      // If there are already obvious bullet-like separators, leave it alone
      if (/[•·]/.test(out)) return out;

      // Insert a separator when a lowercase or ")" is directly followed by Uppercase
      out = out.replace(/([a-z\)])([A-Z])/g, "$1 • $2");

      // Normalize spaces
      return out.replace(/\s+/g, " ");
    }

    /* ============================================================
       Parsing helpers (languages, headings, lists, education)
       ============================================================ */

    // Parse languages from concatenated string like "BengaliEnglish"
    function parseLanguages(s) {
      s = normalizeSpaces(s).replace(/•/g, " ").trim();
      s = s.replace(/([a-z])([A-Z])/g, "$1,$2");
      const parts = s
        .split(/[,/;| ]+/)
        .map((p) => p.trim())
        .filter(Boolean);
      const uniq = Array.from(new Set(parts.map((p) => titleCase(p))));
      return uniq.join(", ");
    }

    function extractHeadingBlock(rawLines, startIdx, stopHeadings) {
      const out = [];
      for (let i = startIdx + 1; i < rawLines.length; i++) {
        const ln = rawLines[i];
        if (stopHeadings.some((h) => ln.toLowerCase().startsWith(h))) break;
        out.push(ln);
      }
      return out;
    }

    function findHeading(rawLines, headingVariants) {
      const keys = headingVariants.map((h) => h.toLowerCase());
      for (let i = 0; i < rawLines.length; i++) {
        const ln = rawLines[i].toLowerCase();
        if (keys.some((h) => ln.startsWith(h))) {
          return i;
        }
      }
      return -1;
    }

    function joinBlock(block) {
      return block.map(normalizeSpaces).join(" ");
    }

    // Heuristic to pair institutions with details in the education block
    function parseEducation(block) {
      const items = [];
      let i = 0;
      while (i < block.length) {
        let inst = block[i];
        let detail = "";
        if (
          i + 1 < block.length &&
          /Residency|Fellowship|Medical Education|Chief|Cardiology|Medicine|BMBCh|BM BCh|MD|DO|PhD|Board/i.test(
            block[i + 1]
          )
        ) {
          detail = block[i + 1];
          i += 2;
        } else {
          i += 1;
        }
        inst = normalizeSpaces(inst);
        detail = normalizeSpaces(detail);
        if (inst) {
          items.push(detail ? `${inst} — ${detail}` : inst);
        }
      }
      return items;
    }

    function parseList(block) {
      const items = block
        .map((s) => normalizeSpaces(s).replace(/^•\s*/, "").trim())
        .filter(Boolean);
      return items;
    }

    /* ============================================================
       Name / specialty detection
       ============================================================ */

    function isLikelyName(line) {
      const s = (line || "").trim();
      if (!s) return false;
    
      // Never treat the site name or obvious UI chrome as the physician name
      if (/johns hopkins medicine/i.test(s)) return false;
      if (/loading complete/i.test(s)) return false;
    
      // Explicitly exclude common header phrases we never want as names
      if (/accepting new patients/i.test(s)) return false;
      if (/out of 5 stars/i.test(s)) return false;
      if (/ratings?/i.test(s)) return false;
    
      const parts = s.split(/\s+/);
      if (parts.length < 2 || parts.length > 4) return false;
    
      function okWord(p) {
        // Normal case: capitalized word
        if (/^[A-Z][a-zA-Z.'-]+$/.test(p)) return true;
    
        // Allow short lowercase prefix + capital (e.g., "deBettencourt", "vanHouten")
        if (/^[a-z]{1,3}[A-Z][a-zA-Z.'-]+$/.test(p)) return true;
    
        return false;
      }
    
      return parts.every(okWord);
    }


    function isNoiseForSpecialty(line) {
      const s = (line || "").trim();
      if (!s) return true;
      if (/Accepting New Patients/i.test(s)) return true;
      if (/Online Booking/i.test(s)) return true;
      if (/out of 5 stars?/i.test(s)) return true; // rating line
      if (/ratings|reviews/i.test(s)) return true;
      if (/Highlights|Age Groups Seen|Languages|In-Network Plans/i.test(s)) return true;
      return false;
    }


    // Try to reconstruct name / credentials / specialty from the pasted text
    function findNameAndSpecialty(rawLines) {
      let name = "";
      let creds = "";
      let specialty = "";

      const credTokens = [
        // Core physician degrees
        "MD",
        "DO",
        "MBBS",
        "MBBCh",
        "MBBChBAO",
        "BMBCh",
        "BM BCh",

        // Dentistry
        "DDS",

        // Pharmacy
        "PharmD",

        // Doctoral / research / public health
        "PhD",
        "ScD",
        "DrPH",
        "DPH",

        // Veterinary
        "DVM",
        "VMD",
        "VetMB",

        // Law / business / admin
        "JD",
        "MBA",
        "MPA",
        "MSHA",

        // Master’s / science / health science
        "MA",
        "MS",
        "MSc",
        "MSE",
        "MAS",
        "MEd",
        "MHS",
        "MPhil",
        "M Math",
        "SM",
        "ScM",
        "AM",
        "Laurea",
        "Master of Biotechnology",

        // Public health & related
        "MPH",
        "MSPH",
        "MHSc",

        // Nursing / advanced practice
        "DNP",
        "CNM",
        "CRNP",
        "NP",
        "CNP",
        "FNP",

        // Rehab / therapy
        "DPT",
        "MPT",
        "OTD",
        "OT",
        "SLP",

        // Vision / podiatry
        "OD",
        "DPM",

        // Genetics / counseling / social work
        "MGC",
        "MSW",

        // Informatics / bioethics
        "MBE",
        "MBI",

        // Dietetics / nutrition
        "RD",

        // Other medical / allied
        "ScM",

        // Existing subspecialty/board-style ones
        "FACC",
        "FSCAI",

        // Already-supported degrees that should remain
        "AuD"
      ];

      // 1) Try the structured header pattern around "Print"
      const idxPrint = rawLines.findIndex((l) => /^Print$/i.test((l || "").trim()));
      const startIdx = idxPrint >= 0 ? idxPrint + 1 : 0;
      const endIdx = Math.min(startIdx + 12, rawLines.length);

      for (let i = startIdx; i < endIdx; i++) {
        const line = rawLines[i];
        if (!isLikelyName(line)) continue;

        // Likely plain name line (e.g., "Erin Brown")
        name = line.trim();

        // Look for "Name, Credentials" on the next line
        if (i + 1 < rawLines.length) {
          const next = (rawLines[i + 1] || "").trim();
          const m = next.match(/^(.+?),\s*(.+)$/);
          if (m) {
            const firstWord = name.split(/\s+/)[0].toLowerCase();
            const firstWordNext = m[1].split(/\s+/)[0].toLowerCase();
            if (firstWord === firstWordNext) {
              creds = m[2].trim();
            }
          }
        }

        // Find specialty: first short, non-noise line after the name/cred block
        for (let j = i + 1; j < i + 8 && j < rawLines.length; j++) {
          const cand = (rawLines[j] || "").trim();
          if (!cand || isNoiseForSpecialty(cand)) continue;
          if (/johns hopkins/i.test(cand)) continue;

          // Don't treat "Name, Credentials" as a specialty
          if (name && cand.toLowerCase().includes(name.toLowerCase())) continue;

          if (cand.includes(":")) continue;
          if (cand.length > 200) continue; // allow long multi-phrase specialties
          specialty = cand;
          break;
        }

        break; // done with structured header parse
      }

      // 2) Fallback logic using lines (only scan header area, and avoid addresses)
      if (!name || !specialty) {
        const headerLimit = Math.min(rawLines.length, 80); // look only near the top
        for (let i = 0; i < headerLimit; i++) {
          const ln = (rawLines[i] || "").trim();
          if (!ln) continue;
          if (/back to search|new search|search]/i.test(ln)) continue;
          if (/johns hopkins medicine/i.test(ln)) continue;

          // Match "First Last Jr., MD" style lines; avoid addresses
          const m = ln.match(
            /^([A-Z][A-Za-z.'-]+(?:\s+[A-Z][A-Za-z.'-]+)*(?:\s+(Jr\.?|Sr\.?|II|III|IV|V))?),\s*(.+)$/
          );
          if (!m) continue;

          const candidateName = m[1].trim();
          const candidateCreds = m[3].trim();

          // Only accept if the "after comma" part really looks like credentials
          if (!credTokens.some((t) => new RegExp("\\b" + t + "\\b").test(candidateCreds))) {
            continue;
          }

          name = candidateName;
          creds = candidateCreds;

          // Specialty in nearby lines
          for (let j = i + 1; j < i + 8 && j < rawLines.length; j++) {
            const nxt = (rawLines[j] || "").trim();
            if (!nxt) continue;
            if (isNoiseForSpecialty(nxt)) continue;
            if (/johns hopkins/i.test(nxt)) continue;

            // Skip lines that clearly repeat the name
            if (name && nxt.toLowerCase().includes(name.toLowerCase())) continue;

            if (nxt.includes(":")) break;
            if (nxt.length > 200) continue;
            specialty = nxt;
            break;
          }

          break;
        }
      }

      // 3) Extra regex fallback on the whole text
      if (!name) {
        const whole = rawLines.join(" ");
        const nameMatch = whole.match(
          /([A-Z][a-zA-Z.'-]+(?:\s+[A-Z][a-zA-Z.'-]+){1,3}),\s*(MD|DO|PhD|MBBS|BMBCh|BM BCh|FACC|FSCAI|MBA|MPH|MS|CRNP|NP|CNP|FNP|DNP|PA-C|AuD)/
        );
        if (nameMatch) {
          name = nameMatch[1].trim();
          creds = nameMatch[2].trim();
        }
      }

      // 4) Last-resort: first "nice" name line that is not JH branding
      if (!name) {
        for (let i = 0; i < rawLines.length; i++) {
          if (isLikelyName(rawLines[i])) {
            name = rawLines[i].trim();
            break;
          }
        }
      }

      // Repair stripped formatting like "Spine SurgeryNeurosurgeryNeurosurgical Oncology"
      specialty = fixSpecialtyFormatting(specialty);

      return { name, creds, specialty };
    }
    
    /* ============================================================
       Location parsing
       ============================================================ */
    
    function parseLocations(rawLines) {
      // Use the *last* occurrence of a standalone "Locations" heading,
      // since there's also a navigation tab named Locations near the top.
      let idxLocations = -1;
      for (let i = 0; i < rawLines.length; i++) {
        const v = (rawLines[i] || "").trim();
        if (/^Locations$/i.test(v)) idxLocations = i;
      }
      if (idxLocations < 0) return [];
    
      const block = [];
      for (let i = idxLocations + 1; i < rawLines.length; i++) {
        const s = (rawLines[i] || "").trim();
        if (!s) continue;
    
        // Skip junk lines we never want to treat as locations
        if (/^show more$/i.test(s) || /^show less$/i.test(s)) continue;
        if (/maplibre|openstreetmap/i.test(s)) continue;
        if (/^get directions$/i.test(s)) continue;
        if (/^loading booking information complete/i.test(s)) continue;
        if (/^schedule appointment/i.test(s)) continue;
        if (/^schedule an appointment/i.test(s)) continue;
    
        // Stop when we hit the next big section
        if (
          /^(experience|expertise|education|insurance|reviews?|ratings|board certifications?)$/i.test(s) ||
          /^ratings & reviews/i.test(s)
        ) {
          break;
        }
    
        block.push(s);
      }
    
      const locations = [];
      let i = 0;
    
      while (i < block.length) {
        let name = block[i] || "";
        // Strip any leading numbering like "1 " or "2 "
        name = name.replace(/^\d+\s+/, "");
    
        let address = "";
        let phone = "";
        let fax = "";
    
        // Next non-phone line is usually the address
        if (
          i + 1 < block.length &&
          !/^phone\b/i.test(block[i + 1]) &&
          !/^fax\b/i.test(block[i + 1])
        ) {
          address = block[i + 1];
          i += 2;
        } else {
          i += 1;
        }
    
        // Consume phone/fax lines for this location
        while (
          i < block.length &&
          (/^phone\b/i.test(block[i]) || /^fax\b/i.test(block[i]))
        ) {
          const line = block[i];
          const mPhone = line.match(/phone:\s*([0-9().-\s]+)/i);
          if (mPhone) phone = mPhone[1].trim();
    
          const mFax = line.match(/fax:\s*([0-9().-\s]+)/i);
          if (mFax) fax = mFax[1].trim();
    
          i++;
        }
    
        // Skip completely empty entries
        if (!name && !address && !phone && !fax) continue;
    
        locations.push({
          name: normalizeSpaces(name),
          address: normalizeSpaces(address),
          phone,
          fax
        });
      }
    
      return locations;
    }
    
    /* ============================================================
       Top-level parse function
       ============================================================ */

    function parseDoctorText(text) {
      const rawLines = lines(text);
      const { name, creds, specialty } = findNameAndSpecialty(rawLines);

      // Affiliations
      let affiliations = "";
      for (let i = 0; i < rawLines.length; i++) {
        const ln = rawLines[i];
        const m = ln.match(/Johns Hopkins Affiliations:?(.+)?/i);
        if (m) {
          affiliations = m[1] ? normalizeSpaces(m[1]) : "";
          if (!affiliations && i + 1 < rawLines.length) {
            affiliations = normalizeSpaces(rawLines[i + 1] || "");
          }
          break;
        }
      }
      
      // Languages
      let languages = "";
      let idxLang = findHeading(rawLines, ["Languages", "Language"]);
      if (idxLang >= 0) {
        const block = extractHeadingBlock(rawLines, idxLang, [
          "gender",
          "professional titles",
          "primary academic title",
          "about",
          "background",
          "education",
          "in-network plans",
          "age groups seen",
          "locations",
          "experience",
          "expertise",
          "conditions treated",
          "treatments & procedures",
          "treatments and procedures",
          "procedures",
          "insurance",
          "ratings & reviews",
          "ratings",
          "reviews",
          "board certifications",
          "memberships",
          "schedule appointment",
          "schedule an appointment"
        ]);
        const langLine =
          joinBlock(block).trim() || (rawLines[idxLang].split(":")[1] || "");
        languages = parseLanguages(langLine);
      }
      
      // Gender
      let gender = "";
      let idxGender = findHeading(rawLines, ["Gender"]);
      if (idxGender >= 0) {
        const block = extractHeadingBlock(rawLines, idxGender, [
          "languages",
          "professional titles",
          "primary academic title",
          "about",
          "background",
          "education",
          "locations",
          "experience",
          "expertise",
          "insurance",
          "ratings & reviews",
          "ratings",
          "reviews",
          "board certifications",
          "memberships",
          "schedule appointment",
          "schedule an appointment"
        ]);
        gender = block[0]
          ? normalizeSpaces(block[0])
          : (rawLines[idxGender].split(":")[1] || "").trim();
      }
      
      // Titles
      let titles = [];
      let idxTitles = findHeading(rawLines, ["Professional Titles"]);
      if (idxTitles >= 0) {
        const block = extractHeadingBlock(rawLines, idxTitles, [
          "primary academic title",
          "languages",
          "gender",
          "background",
          "about",
          "education",
          "locations",
          "experience",
          "expertise",
          "insurance",
          "ratings & reviews",
          "ratings",
          "reviews",
          "board certifications",
          "memberships",
          "schedule appointment",
          "schedule an appointment"
        ]);
        titles = parseList(block);
      }
      
      // Academic title
      let academicTitle = "";
      let idxAcademic = findHeading(rawLines, ["Primary Academic Title"]);
      if (idxAcademic >= 0) {
        const block = extractHeadingBlock(rawLines, idxAcademic, [
          "professional titles",
          "languages",
          "gender",
          "background",
          "about",
          "education",
          "locations",
          "experience",
          "expertise",
          "insurance",
          "ratings & reviews",
          "ratings",
          "reviews",
          "board certifications",
          "memberships",
          "schedule appointment",
          "schedule an appointment"
        ]);
        academicTitle = block[0]
          ? normalizeSpaces(block[0])
          : (rawLines[idxAcademic].split(":")[1] || "").trim();
      } else {
        const fallback = rawLines.find(
          (l) =>
            /Professor|Associate Professor|Assistant Professor/i.test(l) &&
            l.length < 160 &&
            !/johns hopkins medicine/i.test(l)
        );
        if (fallback) academicTitle = normalizeSpaces(fallback);
      }
      
      // Background / About
      let background = "";
      let idxBackground = findHeading(rawLines, ["Background"]);
      if (idxBackground >= 0) {
        const block = extractHeadingBlock(rawLines, idxBackground, [
          "education",
          "board certifications",
          "memberships",
          "videos",
          "selected publications",
          "locations",
          "experience",
          "expertise",
          "conditions treated",
          "treatments & procedures",
          "treatments and procedures",
          "procedures",
          "insurance",
          "ratings & reviews",
          "ratings",
          "reviews",
          // extra headings we don't want in the PDF
          "centers and institutes",
          "recent news articles and media coverage",
          "additional academic titles",
          "research interests",
          "lab website",
          "x (twitter)",
          "twitter",
          "schedule appointment",
          "schedule an appointment",
          "language assistance available",
          "contact & privacy information",
          "price transparency",
          "terms & conditions of use",
          "non-discrimination notice",
          "follow on facebook",
          "follow on twitter",
          "follow on linkedin",
          "follow on instagram",
          "follow on youtube",
          "follow on weibo"
        ]);
        background = joinBlock(block);
      } else {
        let idxAbout = findHeading(rawLines, ["About"]);
        if (idxAbout >= 0) {
          const block = extractHeadingBlock(rawLines, idxAbout, [
            "locations",
            "experience",
            "expertise",
            "conditions treated",
            "treatments & procedures",
            "treatments and procedures",
            "procedures",
            "insurance",
            "ratings & reviews",
            "ratings",
            "reviews",
            "education",
            "board certifications",
            "memberships",
            "videos",
            "selected publications",
            "centers and institutes",
            "recent news articles and media coverage",
            "additional academic titles",
            "research interests",
            "lab website",
            "x (twitter)",
            "twitter",
            "schedule appointment",
            "schedule an appointment",
            "language assistance available",
            "contact & privacy information"
          ]);
          background = joinBlock(block);
        }
      }

      // Education
      let education = [];
      let idxEducation = findHeading(rawLines, ["Education"]);
      if (idxEducation >= 0) {
        const block = extractHeadingBlock(rawLines, idxEducation, [
          "board certifications",
          "memberships",
          "videos",
          "selected publications",
          "locations",
          "experience",
          "expertise",
          "conditions treated",
          "treatments & procedures",
          "treatments and procedures",
          "procedures",
          "insurance",
          "ratings & reviews",
          "ratings",
          "reviews",
          "schedule appointment",
          "schedule an appointment"
        ]);
        education = parseEducation(block);
      }
      
      // Board certifications
      let certifications = [];
      let idxCerts = findHeading(rawLines, ["Board Certifications", "Board Certification"]);
      if (idxCerts >= 0) {
        const block = extractHeadingBlock(rawLines, idxCerts, [
          "education",
          "memberships",
          "videos",
          "selected publications",
          "locations",
          "experience",
          "expertise",
          "conditions treated",
          "treatments & procedures",
          "treatments and procedures",
          "procedures",
          "insurance",
          "ratings & reviews",   // <-- key fix for your case
          "ratings",
          "reviews",
          "schedule appointment",
          "schedule an appointment"
        ]);
        certifications = parseEducation(block);
      }
      
      // Memberships
      let memberships = [];
      let idxMembers = findHeading(rawLines, ["Memberships", "Membership"]);
      if (idxMembers >= 0) {
        const block = extractHeadingBlock(rawLines, idxMembers, [
          "education",
          "board certifications",
          "videos",
          "selected publications",
          "locations",
          "experience",
          "expertise",
          "conditions treated",
          "treatments & procedures",
          "treatments and procedures",
          "procedures",
          "insurance",
          "ratings & reviews",
          "ratings",
          "reviews",
          "schedule appointment",
          "schedule an appointment"
        ]);
        memberships = parseList(block);
      }
      
      const locations = parseLocations(rawLines);

      // Derive credentials from "Name, Credentials" if we haven't yet
      let credentials = creds;
      if (!credentials && name) {
        const near = rawLines.find((l) => l.includes(name) && l.includes(","));
        if (near) credentials = near.replace(name, "").replace(/^,\s*/, "").trim();
      }

      return {
        name: name || "Physician Name",
        credentials: credentials || "",
        specialty: specialty || "",
        affiliations: affiliations || "",
        languages: languages || "",
        gender: gender || "",
        titles,
        academicTitle,
        background,
        education,
        certifications,
        memberships,
        locations
      };
    }

    /* ============================================================
       Populate preview from parsed data
       ============================================================ */

    function populatePreview(data) {
      const nameEl = document.getElementById("nameField");
      const credsEl = document.getElementById("credentialsField");
      const specEl = document.getElementById("specialtyField");

      const hasName = !!(data.name && data.name.trim());
      const hasCreds = !!(data.credentials && data.credentials.trim());

      const displayName = hasName
        ? hasCreds
          ? `${data.name.trim()}, ${data.credentials.trim()}`
          : data.name.trim()
        : "Physician Name";

      nameEl.textContent = displayName;

      // Credentials are merged into the name line, so hide the dedicated field
      if (credsEl) {
        credsEl.textContent = "";
        credsEl.style.display = "none";
      }

      const specialtyText =
        (data.specialty && data.specialty.trim()) || "Specialty";
      specEl.textContent = specialtyText;

      document.getElementById("affiliationsField").textContent =
        data.affiliations || "—";
      document.getElementById("languagesField").textContent =
        data.languages || "—";
      document.getElementById("genderField").textContent =
        data.gender || "—";
      document.getElementById("academicTitleField").textContent =
        data.academicTitle || "—";

      // Helper to populate <ul> lists with fallback "—"
      function populateList(listId, items) {
        const listEl = document.getElementById(listId);
        listEl.innerHTML = "";
        (items && items.length ? items : ["—"]).forEach((item) => {
          const li = document.createElement("li");
          li.textContent = item;
          listEl.appendChild(li);
        });
      }

      populateList("titlesList", data.titles);
      populateList("educationList", data.education);
      populateList("certificationsList", data.certifications);
      populateList("membershipsList", data.memberships);

      // Locations (with numbering, bold headers, cleaned whitespace)
      const locationsField = document.getElementById("locationsField");
      locationsField.innerHTML = "";

      function cleanLine(str) {
        if (!str) return "";
        return escapeHtml(str.replace(/^\s+|\s+$/g, "")); // trims all whitespace including newlines
      }

      if (data.locations && data.locations.length) {
        const indent = `<span style="margin-left: 10px;"></span>`;
      
        const blocks = data.locations.map((loc, index) => {
          let lines = [];
      
          const locName = cleanLine(loc.name);
          const address = cleanLine(loc.address);
          const phone = cleanLine(loc.phone);
          const fax = cleanLine(loc.fax);
      
          const numberPrefix = (index + 1) + ". ";
          
          // First line: name only (no indent)
          let firstLine = `<strong>${numberPrefix}${locName || "Location"}</strong>`;
          lines.push(firstLine);
      
          // Address line WITH indent
          if (address) {
            lines.push(`${indent}${address}`);
          }
      
          // Phone / Fax with indent
          const phoneFax = [];
          if (phone) phoneFax.push("Phone: " + phone);
          if (fax) phoneFax.push("Fax: " + fax);
          if (phoneFax.length) {
            lines.push(`${indent}${phoneFax.join(" • ")}`);
          }
      
          return lines.join("<br>");
        });
      
        // Exactly one blank line between locations
        locationsField.innerHTML = blocks.join("<br><br>");
      
      } else {
        locationsField.textContent = "—";
      }

      const bgEl = document.getElementById("backgroundField");
      bgEl.textContent = data.background || "—";

      // ===== Auto-hide empty sections (except Background) =====
      (function autoHideEmptySections() {
        const autoHideKeys = new Set([
          "affiliations",
          "languages",
          "gender",
          "titles",
          "academic",
          "education",
          "certifications",
          "memberships",
          "locations"
        ]);
      
        const fields = document.querySelectorAll(".field");
      
        fields.forEach((field) => {
          const key = field.dataset.field;
          if (!key) return;
      
          // Never auto-hide Background
          if (key === "background") return;
      
          // Only auto-hide the specific sections listed above
          if (!autoHideKeys.has(key)) return;
      
          const valueEl = field.querySelector(".value, .list");
          if (!valueEl) return;
      
          let isEmpty = false;
      
          if (valueEl.tagName === "UL") {
            // Lists: empty if no <li> or only "—"
            const items = Array.from(valueEl.querySelectorAll("li"));
            if (
              items.length === 0 ||
              (items.length === 1 && items[0].textContent.trim() === "—")
            ) {
              isEmpty = true;
            }
          } else {
            // Normal value
            const text = valueEl.textContent.trim();
            if (!text || text === "—") {
              isEmpty = true;
            }
          }
      
          if (isEmpty) {
            field.classList.add("hidden");
          } else {
            field.classList.remove("hidden");
          }
        });
      })();

      
      // After updating content, make sure float + page breaks are correct
      ensureBackgroundClears();
    }

    /* ============================================================
       Page guide / layout helpers
       ============================================================ */

    function updatePageGuides() {
      const pageEl = document.getElementById("pdfPage");
      if (!pageEl) return;

      // Remove existing guides
      pageEl.querySelectorAll(".page-guide").forEach((el) => el.remove());

      const styles = getComputedStyle(document.documentElement);
      const raw = styles.getPropertyValue("--page-height").trim();
      const pageHeight = parseInt(raw, 10);
      if (!pageHeight) return;

      const totalHeight = pageEl.scrollHeight;
      let page = 2;
      for (let offset = pageHeight; offset < totalHeight; offset += pageHeight) {
        const guide = document.createElement("div");
        guide.className = "page-guide";
        guide.style.top = offset + "px";

        const label = document.createElement("span");
        label.textContent = "Page " + page;
        guide.appendChild(label);

        pageEl.appendChild(guide);
        page++;
      }
    }

    // Try to avoid sections straddling a page boundary (except background)
    function applySectionPageBreaks() {
      const pageEl = document.getElementById("pdfPage");
      if (!pageEl) return;

      const styles = getComputedStyle(document.documentElement);
      const raw = styles.getPropertyValue("--page-height").trim();
      const pageHeight = parseInt(raw, 10);
      if (!pageHeight) return;

      const fields = Array.from(pageEl.querySelectorAll(".field"));

      // Reset any previous adjustments to get a clean layout
      fields.forEach((field) => {
        if (!field.dataset.baseMarginTop) {
          field.dataset.baseMarginTop =
            getComputedStyle(field).marginTop || "0px";
        }
        field.style.marginTop = field.dataset.baseMarginTop;
      });

      const pageRect = pageEl.getBoundingClientRect();
      const EXTRA = 60; // how far below the new page top we push the section
      const GUARD = 10; // how close to a page break we treat as "crossing"

      fields.forEach((field) => {
        // Background is allowed to spill across pages
        if (field.dataset.field === "background") return;
        if (field.classList.contains("hidden")) return;

        const rect = field.getBoundingClientRect();
        const top = rect.top - pageRect.top;      // px from top of layout
        const bottom = rect.bottom - pageRect.top;

        const startPage = Math.floor(top / pageHeight);
        const boundary = (startPage + 1) * pageHeight; // first boundary below this section

        // If the bottom is past the boundary - GUARD, treat it as crossing
        if (bottom > boundary - GUARD) {
          const shift = boundary - top + EXTRA;

          const current =
            parseFloat(field.style.marginTop || field.dataset.baseMarginTop || "0") || 0;
          field.style.marginTop = current + shift + "px";
        }
      });
    }

    // Ensure the "Background" section clears the photo float and adjust page breaks
    function ensureBackgroundClears() {
      const photoBox = document.querySelector(".photo-box");
      const backgroundField = document.querySelector('[data-field="background"]');

      if (!photoBox || !backgroundField) {
        applySectionPageBreaks();
        updatePageGuides();
        return;
      }

      const allFields = Array.from(document.querySelectorAll(".field"));
      const backgroundIndex = allFields.indexOf(backgroundField);
      const fieldsBeforeBackground = allFields
        .slice(0, backgroundIndex)
        .filter((f) => !f.classList.contains("hidden"));

      let cumulativeHeight = 0;
      fieldsBeforeBackground.forEach((field) => {
        cumulativeHeight += field.offsetHeight;
      });

      if (cumulativeHeight < photoBox.offsetHeight) {
        backgroundField.classList.add("clear-float");
      } else {
        backgroundField.classList.remove("clear-float");
      }

      applySectionPageBreaks();
      updatePageGuides();
    }

    // Recalculate layout after inline edits (debounced)
    const recalcLayoutAfterEdit = debounce(() => {
      ensureBackgroundClears();
    }, 150);

    function attachInlineEditListeners() {
      const selectors = [
        "#nameField",
        "#specialtyField",
        "#affiliationsField",
        "#locationsField",
        "#languagesField",
        "#genderField",
        "#academicTitleField",
        "#backgroundField",
        "#titlesList",
        "#educationList",
        "#certificationsList",
        "#membershipsList"
      ];

      selectors.forEach((sel) => {
        const el = document.querySelector(sel);
        if (!el) return;
        el.addEventListener("input", recalcLayoutAfterEdit);
      });
    }

    /* ============================================================
       Photo handling (upload + paste)
       ============================================================ */

    const photoFileInput = document.getElementById("photoFile");
    const photoImg = document.getElementById("photoImg");
    const photoPlaceholder = document.getElementById("photoPlaceholder");
    const photoPreview = document.getElementById("photoPreview");
    const photoPreviewImg = document.getElementById("photoPreviewImg");
    const photoPreviewText = document.getElementById("photoPreviewText");

    // Show image in both preview and floated photo box
    function setPhotoSrc(src) {
      photoImg.src = src;
      photoImg.style.display = "block";
      photoPlaceholder.style.display = "none";

      photoPreviewImg.src = src;
      photoPreviewImg.style.display = "block";
      photoPreviewText.style.display = "none";
    }

    photoFileInput.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (evt) {
        const src = evt.target.result;
        setPhotoSrc(src);
      };
      reader.readAsDataURL(file);
    });

    photoPreview.addEventListener("paste", (event) => {
      if (!event.clipboardData) return;

      const items = event.clipboardData.items;
      for (const item of items) {
        if (item.type.startsWith("image/")) {
          const file = item.getAsFile();
          const reader = new FileReader();

          reader.onload = function (evt) {
            const src = evt.target.result;
            setPhotoSrc(src);
          };

          reader.readAsDataURL(file);
          event.preventDefault();
          break;
        }
      }
    });

    /* ============================================================
       Inline editing & font size controls
       ============================================================ */

    const fontSizeSlider = document.getElementById("fontSizeSlider");
    const fontSizeValue = document.getElementById("fontSizeValue");
    const pageInner = document.getElementById("pageInner");
    const editToggle = document.getElementById("editToggle");

    fontSizeSlider.addEventListener("input", (e) => {
      const size = parseFloat(e.target.value);
      fontSizeValue.textContent = size + "px";

      pageInner.style.setProperty("--content-font-size", size + "px");

      document.querySelectorAll(".value, .list").forEach((el) => {
        el.style.fontSize = size + "px";
      });

      document.querySelectorAll(".label").forEach((el) => {
        el.style.fontSize = size + 1 + "px";
      });

      setTimeout(ensureBackgroundClears, 50);
    });

    editToggle.addEventListener("change", (e) => {
      const editable = e.target.checked;
      pageInner.classList.toggle("editable", editable);
      const ids = [
        "affiliationsField",
        "locationsField",
        "languagesField",
        "genderField",
        "academicTitleField",
        "backgroundField",
        "nameField",
        "credentialsField",
        "specialtyField"
      ];
      ids.forEach((id) => {
        const el = document.getElementById(id);
        el.contentEditable = editable ? "true" : "false";
      });
      document.getElementById("titlesList").contentEditable = editable ? "true" : "false";
      document.getElementById("educationList").contentEditable = editable ? "true" : "false";
      document.getElementById("certificationsList").contentEditable = editable ? "true" : "false";
      document.getElementById("membershipsList").contentEditable = editable ? "true" : "false";
    });

    // Show/hide entire sections with little checkboxes
    document.querySelectorAll(".section-toggle").forEach((checkbox) => {
      checkbox.addEventListener("change", (e) => {
        const field = e.target.closest(".field");
        if (!e.target.checked) {
          field.classList.add("hidden");
        } else {
          field.classList.remove("hidden");
        }
        setTimeout(ensureBackgroundClears, 10);
      });
    });

    /* ============================================================
       Parse / Clear buttons
       ============================================================ */

    const parseBtn = document.getElementById("parseBtn");
    const rawInput = document.getElementById("rawInput");

    parseBtn.addEventListener("click", () => {
      const t = rawInput.value || "";
      if (!t.trim()) {
        alert("Please paste the physician's page text first.");
        return;
      }
      const data = parseDoctorText(t);
      populatePreview(data);

      // Turn on inline editing after a successful parse
      editToggle.checked = true;
      editToggle.dispatchEvent(new Event("change"));
      setTimeout(ensureBackgroundClears, 100);
    });

    document.getElementById("clearBtn").addEventListener("click", () => {
      rawInput.value = "";
      populatePreview({
        name: "Physician Name",
        credentials: "Credentials",
        specialty: "Specialty",
        affiliations: "—",
        languages: "—",
        gender: "—",
        titles: [],
        academicTitle: "—",
        background: "—",
        education: [],
        certifications: [],
        memberships: [],
        locations: []
      });

      // Reset photos
      photoImg.src = "";
      photoImg.style.display = "none";
      photoPlaceholder.style.display = "grid";
      photoPreviewImg.src = "";
      photoPreviewImg.style.display = "none";
      photoPreviewText.style.display = "block";

      // Disable inline editing
      editToggle.checked = false;
      editToggle.dispatchEvent(new Event("change"));

      // Reset font weights / sizes
      fontSizeSlider.value = 14;
      fontSizeValue.textContent = "14px";
      document.querySelectorAll(".value, .list").forEach((el) => {
        el.style.fontSize = "14px";
      });
      document.querySelectorAll(".label").forEach((el) => {
        el.style.fontSize = "15px";
      });

      setTimeout(ensureBackgroundClears, 50);
    });

    /* ============================================================
       PDF download & print
       ============================================================ */

    const downloadBtn = document.getElementById("downloadBtn");
    const printBtn = document.getElementById("printBtn");

    downloadBtn.addEventListener("click", async () => {
      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        alert("PDF library failed to load. Please try reloading the page.");
        return;
      }
      const pageEl = document.getElementById("pdfPage");
      const wasEditable = editToggle.checked;

      // Turn off inline editing while capturing so outlines don't appear
      if (wasEditable) {
        editToggle.checked = false;
        editToggle.dispatchEvent(new Event("change"));
      }

      // Hide guides & border while capturing
      pageEl.classList.add("printing");

      const canvas = await html2canvas(pageEl, {
        backgroundColor: "#ffffff",
        scale: 2,
        useCORS: true,
        logging: false
      });

      // Restore normal appearance
      pageEl.classList.remove("printing");

      if (wasEditable) {
        editToggle.checked = true;
        editToggle.dispatchEvent(new Event("change"));
      }

      const doc = new jsPDF({ unit: "pt", format: "letter" });
      const margin = 36;
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();

      const imgWidth = pageWidth - margin * 2;
      const imgHeight = (canvas.height * imgWidth) / canvas.width;

      const usablePageHeight = pageHeight - margin * 2;
      const totalPages = Math.ceil(imgHeight / usablePageHeight);

      const pageCanvas = document.createElement("canvas");
      const pageCtx = pageCanvas.getContext("2d");

      const pxPageHeight = Math.floor((usablePageHeight * canvas.width) / imgWidth);
      pageCanvas.width = canvas.width;

      for (let page = 0; page < totalPages; page++) {
        const sY = page * pxPageHeight;
        const sHeight = Math.min(pxPageHeight, canvas.height - sY);
        pageCanvas.height = sHeight;

        pageCtx.clearRect(0, 0, pageCanvas.width, pageCanvas.height);
        pageCtx.drawImage(
          canvas,
          0,
          sY,
          canvas.width,
          sHeight,
          0,
          0,
          pageCanvas.width,
          sHeight
        );

        const imgData = pageCanvas.toDataURL("image/jpeg", 0.95);
        if (page > 0) {
          doc.addPage();
        }
        const renderHeight = (sHeight * imgWidth) / canvas.width;
        doc.addImage(imgData, "JPEG", margin, margin, imgWidth, renderHeight);
      }

      const nameText =
        (document.getElementById("nameField").textContent || "Physician").replace(
          /\s+/g,
          "_"
        );
      doc.save(`${nameText}_Bio.pdf`);
    });

    printBtn.addEventListener("click", () => {
      const pageEl = document.getElementById("pdfPage");
      const wasEditable = editToggle.checked;

      // Turn off inline editing while printing so you don't see outlines
      if (wasEditable) {
        editToggle.checked = false;
        editToggle.dispatchEvent(new Event("change"));
      }

      pageEl.classList.add("printing");
      window.print();
      pageEl.classList.remove("printing");

      if (wasEditable) {
        editToggle.checked = true;
        editToggle.dispatchEvent(new Event("change"));
      }
    });

    /* ============================================================
       Initial setup
       ============================================================ */

    // Initial empty preview
    populatePreview({
      name: "Physician Name",
      credentials: "Credentials",
      specialty: "Specialty",
      affiliations: "—",
      languages: "—",
      gender: "—",
      titles: [],
      academicTitle: "—",
      background: "—",
      education: [],
      certifications: [],
      memberships: [],
      locations: []
    });

    // Default font sizes
    document.querySelectorAll(".value, .list").forEach((el) => {
      el.style.fontSize = "14px";
    });
    document.querySelectorAll(".label").forEach((el) => {
      el.style.fontSize = "15px";
    });

    window.addEventListener("load", () => {
      attachInlineEditListeners();
      setTimeout(ensureBackgroundClears, 50);
    });
  </script>
</body>
</html>
